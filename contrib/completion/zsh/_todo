#compdef todo

# {{{ sub commands common options variables
local common_options_help=(
	'(- :)--help[show a help message and exit]'
)
local common_options_start=(
	{-s,--start=}'[when the task starts]:date:__todo_date'
)
local common_options_due=(
	{-d,--due=}'[when the task is due]:date:__todo_date'
)
local common_options_priority=(
	'--priority=[the priority for this todo]:priority:("low" "medium" "high")'
)
local common_options_interactive=(
	{-i,--interactive}'[go into interactive mode before saving the task]'
)
local common_options_location=(
	'--location=[the location where this todo takes place]:location:'
)
# }}}
# {{{ option helper: color mode
__color_mode(){
	local modes=(
		"always:enable regardless of stdout"
		"auto:enable only when not on tty (default)"
		"never:disable colored output entirely"
	)
	_describe "mode" modes
}
# }}}
# {{{ option helper: due and start date
__todo_date(){
	typeset -A date_time_dict
	# setting defaults so no matter if these keys will be parsed from config,
	# we'll have some values here anyway
	date_time_dict[date_format]='%x'
	date_time_dict[dt_separator]=' '
	date_time_dict[time_format]='%X'
	# parse configuration file to get date and time formats from there
	local conf_file="${XDG_CONFIG_DIR:-${HOME}/.config}/todoman/todoman.conf"
	if [[ -f "$conf_file" ]]; then
		while read line; do
			for key in date_format dt_separator time_format; do
				if [[ "$line" =~ "^\s*$key\s*=\s*" ]]; then
					line="${line[$MEND+1,${#line}]}"
					date_time_dict[$key]="$line"
				fi
			done
		done < "$conf_file"
	fi
	# substitute '%' from values so it won't get messy
	local date_format="${date_time_dict[date_format]//\%/%%}"
	local time_format="${date_time_dict[time_format]//\%/%%}"
	local dt_separator="${date_time_dict[dt_separator]}"
	_message -r "date in format ${date_format}${dt_separator}${time_format}"
}
# }}}
# {{{ argument helper: sub-command choice
__todo_command(){
	local commands=(
		'cancel:cancel one or more tasks'
		'copy:copy tasks to another list'
		'delete:delete tasks'
		'done:mark one or more tasks as done'
		'edit:edit the task with id ID'
		'flush:delete done tasks'
		'list:list tasks'
		'move:move tasks to another list'
		'new:create a new task with SUMMARY'
		'show:show details about a task'
	)
	_describe "command" commands
}
# }}}
# {{{ argument helper: available tasks choice
__todo_tasks(){
	local requested_status="$1"
	local -a tasks
	local i st text
	todo list --status="$requested_status" | while read i st_text; do
		tasks+=("$i":"$st_text")
	done
	_describe tasks tasks
}
# }}}
# {{{ option helper: available lists
__todo_lists(){
	local conf_file="${XDG_CONFIG_DIR:-${HOME}/.config}/todoman/todoman.conf"
	local tasks_path
	if [[ -f "$conf_file" ]]; then
		# parse configuration file to get where the tasks are stored (main.path)
		while read line; do
			if [[ "$line" =~ '^\s*path\s*=\s*' ]]; then
				tasks_path=("${line[$MEND+1,${#line}]}")
				break
			fi
		done < "$conf_file"
		if [ -z "${tasks_path+1}" ]; then
			_message -e "no 'path = ' string was found in todoman's default configuration file ($todoman_configuration_file)"
			return 1
		fi
	else
		_message -r "can't display tasks' lists since completion function didn't find the configuration file at $todoman_configuration_file"
		return 1
	fi
	local -a actual_suggestions
	# expand manually * found in tasks_paths array
	local expanded_tasks_paths=(${~tasks_path})
	local expanded_tasks_path
	for expanded_tasks_path in "${expanded_tasks_paths[@]}"; do
		if [[ -r "${expanded_tasks_path}/displayname" ]]; then
			actual_suggestions+=("$(< "${expanded_tasks_path}/displayname")")
		elif [[ -d "${expanded_tasks_path}" ]]; then
			# This leaves only the tail of the expanded path
			actual_suggestions+=("${expanded_tasks_path:t}")
		fi
	done
	_describe -t values list actual_suggestions
}
# }}}
# {{{ command `cancel`
_todo_cancel(){
	_arguments \
		"${common_options_help[@]}" \
		'*: :{__todo_tasks "IN-PROCESS,NEEDS-ACTION"}'
}
# }}}
# {{{ command `copy`
local _command_copy_options=(
	"${common_options_help[@]}"
	{-l,--list=}'[the list to copy the tasks to]:text:__todo_lists'
)
_todo_copy(){
	_arguments \
		"${_command_copy_options[@]}" \
		'*: :{__todo_tasks "IN-PROCESS,NEEDS-ACTION"}'
}
# }}}
# {{{ command `delete`
local _command_delete_options=(
	"${common_options_help[@]}"
	"--yes[don't ask for permission before deleting]"
)
_todo_delete(){
	_arguments \
		"${_command_delete_options[@]}" \
		'*: :{__todo_tasks "IN-PROCESS,NEEDS-ACTION"}'
}
# }}}
# {{{ command `done`
local _command_done_options=(
	"${common_options_help[@]}"
)
_todo_done(){
	_arguments \
		"${_command_done_options[@]}" \
		'*: :{__todo_tasks "IN-PROCESS,NEEDS-ACTION"}'
}
# }}}
# {{{ command `edit`
local _command_edit_options=(
	"${common_options_help[@]}"
	"${common_options_start[@]}"
	"${common_options_due[@]}"
	"${common_options_priority[@]}"
	"${common_options_location[@]}"
	"${common_options_interactive[@]}"
)
_todo_edit(){
	_arguments \
		"${_command_edit_options[@]}" \
		'*: :{__todo_tasks "IN-PROCESS,NEEDS-ACTION"}'
}
# }}}
# {{{ command `flush`
_todo_flush(){
}
# }}}
# {{{ command `list`
_command_list_options=(
	"${common_options_location[@]}"
	'--category=[only show tasks with category containg TEXT]:text:__todo_existing_categories'
	'--grep=[only show tasks with message containg TEXT]:text:'
	'--sort=[sort tasks using these fields]:text:(description location status summary uid rrule percent_complete priority sequence categories completed_at created_at dtstamp start due last_modified)'
	'(--reverse --no-reverse)'{--reverse,--no-reverse}'[sort tasks in reverse order (see --sort)]'
	"${common_options_start[@]}"
	"${common_options_due[@]}"
	"${common_options_priority[@]}"
	'--startable[show only todos which should can be started today]'
	{-s,--status=}'[show only todos with the provided comma-separated statuses]:status:("NEEDS-ACTION" "CANCELLED" "COMPLETED" "IN-PROCESS" "ANY")'
	"${common_options_help[@]}"
)
_todo_list(){
	_arguments \
		"${_command_list_options[@]}" \
		'1: :__todo_lists' \
}
# }}}
# {{{ command `move`
_todo_move(){
	_todo_copy
}
# }}}
# {{{ command `new`
local _command_new_options=(
	"${common_options_start[@]}"
	"${common_options_due[@]}"
	"${common_options_help[@]}"
	{-l,--list=}'[the list to move the tasks to]:text:__todo_lists'
	'--location[the location where this todo takes place.]:location:'
	"${common_options_priority[@]}"
	"${common_options_interactive[@]}"
)
_todo_new(){
	_arguments \
		"${_command_new_options[@]}" \
		'*: :{_message "summary"}'
}
# }}}
# {{{ command `show`
_todo_show(){
	_todo_done
}
# }}}

# The real thing
_arguments -C -A "-*" \
	{-v,--verbosity=}'[set verbosity to the given level]:mode:(CRITICAL ERROR WARNING INFO DEBUG)' \
	'--color=[set colored output mode]:mode:__color_mode' \
	'--porcelain[use a JSON format that will remain stable regadless of configuration or version]' \
	{-h,--humanize}'[format all dates and times in a human friendly way]' \
	'(- :)--version[show the version and exit]' \
	"${common_options_help[@]}" \
	'1: :__todo_command' \
	'*::arg:->args'

case $state in
	(args)
		curcontext="${curcontext%:*:*}:todo_$words[1]:"
		case "${words[1]}" in
			cancel)
				_todo_cancel
				;;
			copy)
				_todo_copy
				;;
			delete)
				_todo_delete
				;;
			done)
				_todo_done
				;;
			edit)
				_todo_edit
				;;
			flush)
				_todo_flush
				;;
			list)
				_todo_list
				;;
			move)
				_todo_move
				;;
			new)
				_todo_new
				;;
			show)
				_todo_show
				;;
		esac
		;;
esac
